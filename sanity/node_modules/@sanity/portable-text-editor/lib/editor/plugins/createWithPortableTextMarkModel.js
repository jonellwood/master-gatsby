"use strict";
/**
 *
 * This plugin will change Slate's default marks model (every prop is a mark) with the Portable Text model (marks is an array of strings on prop .marks).
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.createWithPortableTextMarkModel = void 0;
const lodash_1 = require("lodash");
const slate_1 = require("slate");
const debug_1 = require("../../utils/debug");
const selection_1 = require("../../utils/selection");
const debug = debug_1.debugWithName('plugin:withPortableTextMarkModel');
function createWithPortableTextMarkModel(portableTextFeatures, keyGenerator, change$) {
    return function withPortableTextMarkModel(editor) {
        // Extend Slate's default normalization. Merge spans with same set of .marks when doing merge_node operations
        const { apply, normalizeNode } = editor;
        editor.normalizeNode = nodeEntry => {
            normalizeNode(nodeEntry);
            if (editor.operations.some(op => ['remove_node', 'remove_text', 'merge_node'].includes(op.type))) {
                mergeSpans(editor);
            }
            // Check consistency of markDefs
            if (editor.operations.some(op => ['split_node', 'remove_node', 'remove_text', 'merge_node'].includes(op.type))) {
                normalizeMarkDefs(editor);
            }
            // This should not be needed? Commented out for now.
            // // Ensure that every span node has .marks
            // const [node, path] = nodeEntry
            // if (node._type === portableTextFeatures.types.span.name) {
            //   if (!node.marks) {
            //     debug('Adding .marks to span node')
            //     Transforms.setNodes(editor, {marks: []}, {at: path})
            //   }
            // }
        };
        // Special hook before inserting text at the end of an annotation.
        // Split and remove annotation marks in that case when text is inserted
        editor.apply = op => {
            if (op.type === 'insert_text') {
                const { selection } = editor;
                if (selection && slate_1.Range.isCollapsed(selection)) {
                    const [node] = Array.from(slate_1.Editor.nodes(editor, {
                        mode: 'lowest',
                        at: selection.focus,
                        match: n => n._type === portableTextFeatures.types.span.name,
                        voids: false
                    }))[0] || [undefined];
                    if (node &&
                        node.text &&
                        typeof node.text === 'string' &&
                        node.text.length === selection.focus.offset &&
                        Array.isArray(node.marks) &&
                        node.marks.length > 0) {
                        apply(op);
                        slate_1.Editor.withoutNormalizing(editor, () => {
                            slate_1.Transforms.splitNodes(editor, {
                                match: slate_1.Text.isText,
                                at: Object.assign(Object.assign({}, selection.focus), { offset: selection.focus.offset })
                            });
                            const marksWithoutAnnotationMarks = (Object.assign({}, (slate_1.Editor.marks(editor) || {})).marks || []).filter(mark => portableTextFeatures.decorators.map(t => t.value).includes(mark));
                            slate_1.Transforms.setNodes(editor, { marks: marksWithoutAnnotationMarks }, { at: slate_1.Path.next(selection.focus.path) });
                        });
                        editor.operations.filter(op => op.type !== 'insert_text').map(op => apply(op));
                        return;
                    }
                }
            }
            apply(op);
        };
        // Override built in addMark function
        editor.addMark = (mark) => {
            if (editor.selection) {
                if (slate_1.Range.isExpanded(editor.selection)) {
                    // Split if needed
                    slate_1.Transforms.setNodes(editor, {}, { match: slate_1.Text.isText, split: true });
                    // Use new selection
                    const splitTextNodes = [
                        ...slate_1.Editor.nodes(editor, { at: editor.selection, match: slate_1.Text.isText })
                    ];
                    const shouldRemoveMark = lodash_1.flatten(splitTextNodes.map(item => item[0]).map(node => node.marks)).includes(mark);
                    if (shouldRemoveMark) {
                        editor.removeMark(mark);
                        return;
                    }
                    splitTextNodes.forEach(([node, path]) => {
                        const marks = [
                            ...(Array.isArray(node.marks) ? node.marks : []).filter((eMark) => eMark !== mark),
                            mark
                        ];
                        slate_1.Transforms.setNodes(editor, { marks }, { at: path });
                    });
                    mergeSpans(editor);
                }
                else {
                    const existingMarks = Object.assign({}, (slate_1.Editor.marks(editor) || {})).marks || [];
                    const marks = Object.assign(Object.assign({}, (slate_1.Editor.marks(editor) || {})), { marks: [...existingMarks, mark] });
                    editor.marks = marks;
                }
                editor.onChange();
            }
        };
        // Override built in removeMark function
        editor.removeMark = (mark) => {
            if (editor.selection) {
                if (slate_1.Range.isExpanded(editor.selection)) {
                    // Split if needed
                    slate_1.Transforms.setNodes(editor, {}, { match: slate_1.Text.isText, split: true });
                    const splitTextNodes = [
                        ...slate_1.Editor.nodes(editor, { at: editor.selection, match: slate_1.Text.isText })
                    ];
                    splitTextNodes.forEach(([node, path]) => {
                        slate_1.Transforms.setNodes(editor, {
                            marks: (Array.isArray(node.marks) ? node.marks : []).filter((eMark) => eMark !== mark)
                        }, { at: path });
                    });
                    mergeSpans(editor);
                }
                else {
                    const existingMarks = Object.assign({}, (slate_1.Editor.marks(editor) || {})).marks || [];
                    const marks = Object.assign(Object.assign({}, (slate_1.Editor.marks(editor) || {})), { marks: existingMarks.filter(eMark => eMark !== mark) });
                    editor.marks = marks;
                }
                editor.onChange();
            }
        };
        editor.pteIsMarkActive = (mark) => {
            if (!editor.selection) {
                return false;
            }
            let existingMarks = Object.assign({}, (slate_1.Editor.marks(editor) || {})).marks || [];
            if (slate_1.Range.isExpanded(editor.selection)) {
                Array.from(slate_1.Editor.nodes(editor, { match: slate_1.Text.isText, at: editor.selection })).forEach(n => {
                    const [node] = n;
                    existingMarks = lodash_1.uniq([...existingMarks, ...(node.marks || [])]);
                });
            }
            return existingMarks.includes(mark);
        };
        // Custom editor function to toggle a mark
        editor.pteToggleMark = (mark) => {
            const isActive = editor.pteIsMarkActive(mark);
            if (isActive) {
                debug(`Remove mark '${mark}'`);
                slate_1.Editor.removeMark(editor, mark);
            }
            else {
                debug(`Add mark '${mark}'`);
                slate_1.Editor.addMark(editor, mark, true);
            }
            const newSelection = selection_1.toPortableTextRange(editor);
            if (newSelection) {
                // Emit a new selection here (though it might be the same).
                // This is for toolbars etc that listens to selection changes to update themselves.
                change$.next({ type: 'selection', selection: newSelection });
            }
            editor.onChange();
        };
        return editor;
    };
    /**
     * Normalize re-marked spans in selection
     * @param {Editor} editor
     */
    function mergeSpans(editor) {
        const { selection } = editor;
        if (selection) {
            for (const [node, path] of Array.from(slate_1.Editor.nodes(editor, {
                at: slate_1.Editor.range(editor, [selection.anchor.path[0]], [selection.focus.path[0]])
            })).reverse()) {
                const [parent] = path.length > 1 ? slate_1.Editor.node(editor, slate_1.Path.parent(path)) : [undefined];
                const nextPath = [path[0], path[1] + 1];
                if (slate_1.Editor.isBlock(editor, parent)) {
                    const nextNode = parent.children[nextPath[1]];
                    if (node._type === 'span' &&
                        nextNode &&
                        nextNode._type === 'span' &&
                        lodash_1.isEqual(nextNode.marks, node.marks)) {
                        slate_1.Transforms.mergeNodes(editor, { at: nextPath, voids: true });
                    }
                }
            }
        }
    }
    /**
     * Normalize markDefs
     *
     * @param {Editor} editor
     */
    function normalizeMarkDefs(editor) {
        const { selection } = editor;
        if (selection) {
            const blocks = slate_1.Editor.nodes(editor, {
                at: selection,
                match: n => n._type === portableTextFeatures.types.block.name
            });
            for (const [block, path] of blocks) {
                if (Array.isArray(block.markDefs) && slate_1.Element.isElement(block)) {
                    const newMarkDefs = block.markDefs.filter(def => {
                        return block.children.find(child => {
                            return Array.isArray(child.marks) && child.marks.includes(def._key);
                        });
                    });
                    const isEmptySingleChild = block.markDefs.length > 0 &&
                        block.children.length === 1 &&
                        block.children[0].text === '';
                    if (!lodash_1.isEqual(newMarkDefs, block.markDefs) || isEmptySingleChild) {
                        debug('Removing markDef not in use');
                        slate_1.Transforms.setNodes(editor, {
                            markDefs: isEmptySingleChild ? [] : newMarkDefs
                        }, { at: path });
                    }
                }
            }
        }
    }
}
exports.createWithPortableTextMarkModel = createWithPortableTextMarkModel;
//# sourceMappingURL=createWithPortableTextMarkModel.js.map